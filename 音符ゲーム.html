<!DOCTYPE html>
<html lang="ja">

    <head>
        <meta charset="UTF-8">
        <title>音符ゲーム（スイカゲーム風）</title>
        <style>
            canvas {
                background: #fff;
                display: block;
                margin: 0 auto;
            }
        </style>
    </head>

    <body>
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
        <script>
            const { Engine, Render, Runner, World, Bodies, Body, Events } = Matter;

            // 音符タイプの定義
            const noteTypes = [
                { name: "64分音符", radius: 7, next: 1, color: "#eef" },
                { name: "32分音符", radius: 10, next: 2, color: "#ddf" },
                { name: "16分音符", radius: 15, next: 3, color: "#aaf" },
                { name: "8分音符", radius: 25, next: 4, color: "#55f" },
                { name: "4分音符", radius: 35, next: 5, color: "#5f5" },
                { name: "2分音符", radius: 45, next: 6, color: "#fa5" },
                { name: "1分音符", radius: 60, next: null, color: "#f55" }, // 最大
            ];

            const engine = Engine.create();
            const world = engine.world;
            const canvas = document.getElementById("gameCanvas");
            const render = Render.create({
                canvas: canvas,
                engine: engine,
                options: {
                    width: 400,
                    height: 600,
                    wireframes: false,
                    background: '#fff'
                }
            });

            // 地面・壁
            World.add(world, [
                Bodies.rectangle(200, 600, 400, 50, { isStatic: true }),
                Bodies.rectangle(0, 300, 50, 600, { isStatic: true }),
                Bodies.rectangle(400, 300, 50, 600, { isStatic: true }),
            ]);

            // 音符を生成
            function createNote(typeIndex, x, y) {
                const type = noteTypes[typeIndex];
                return Bodies.circle(x, y, type.radius, {
                    label: "note",
                    render: {
                        fillStyle: type.color
                    },
                    noteType: typeIndex
                });
            }// 仮音符（Canvas描画＋座標のみ管理）
            let pendingNoteX = 200; // 初期位置（画面中央）
            const pendingNoteY = 30;
            // 4種類のうちからランダムに選ぶ (index 0..3)
            function pickRandomPendingType() {
                return Math.floor(Math.random() * 4);
            }
            let pendingNoteType = pickRandomPendingType();

            // 仮音符のCanvas描画（毎フレーム）
            function drawPendingNote(ctx) {
                const type = noteTypes[pendingNoteType];
                ctx.beginPath();
                ctx.arc(pendingNoteX, pendingNoteY, type.radius, 0, 2 * Math.PI);
                ctx.fillStyle = type.color;
                ctx.globalAlpha = 0.8; // 半透明など
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            // --- 追加: スタックが上まで来たら上空から落ちてくるようにする ---
            function getTopmostNoteY() {
                const notes = world.bodies.filter(b => b.label === "note");
                if (!notes.length) return Infinity;
                // 各ノートの上端 (中心 - 半径) を計算して最小値を返す
                return Math.min(...notes.map(n => {
                    const r = n.circleRadius || ((n.bounds.max.y - n.bounds.min.y) / 2);
                    return n.position.y - r;
                }));
            }

            function computeSpawnY() {
                const topY = getTopmostNoteY();
                const THRESHOLD = 80; // この値より上（小さいY）にノートがあると上から溢れる扱いにする
                if (topY <= THRESHOLD) {
                    // 上空（キャンバス外）からランダム高さで落とす
                    return - (20 + Math.random() * 120);
                }
                // 通常は仮音符の表示位置から落とす
                return pendingNoteY;
            }
            // --- 追加ここまで ---

            // 落下位置を示す縦線を描画
            function drawGuideLine(ctx) {
                const h = render.options && render.options.height ? render.options.height : canvas.height;
                ctx.save();
                ctx.strokeStyle = 'rgba(85,85,255,0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 6]);
                ctx.beginPath();
                ctx.moveTo(pendingNoteX, 0);
                ctx.lineTo(pendingNoteX, h);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
            }

            // Render の描画後にガイド線と仮音符を描く
            Events.on(render, 'afterRender', function () {
                const ctx = render.context;
                drawGuideLine(ctx);
                drawPendingNote(ctx);
            });

            // キー操作（左/右で仮音符移動、Space/下で仮音符を落とす）
            document.removeEventListener && document.removeEventListener("keydown", null); // 保険（古いハンドラが残る環境対策）
            document.addEventListener("keydown", e => {
                if (e.code === "ArrowLeft") {
                    pendingNoteX = Math.max(pendingNoteX - 20, 50); // 左端制限
                    e.preventDefault();
                } else if (e.code === "ArrowRight") {
                    pendingNoteX = Math.min(pendingNoteX + 20, 350); // 右端制限
                    e.preventDefault();
                } else if (e.code === "Space" || e.code === "ArrowDown") {
                    // 画面内のスタック状態を見て、必要なら上空から落とす
                    const spawnY = computeSpawnY();
                    const note = createNote(pendingNoteType, pendingNoteX, spawnY);
                    World.add(world, note);
                    // 次の仮音符種類をランダムに更新
                    pendingNoteType = pickRandomPendingType();
                    e.preventDefault();
                }
            });

            // 合体判定
            Events.on(engine, "collisionStart", event => {
                event.pairs.forEach(pair => {
                    const a = pair.bodyA;
                    const b = pair.bodyB;
                    if (a.label === "note" && b.label === "note" && a.noteType === b.noteType && a.noteType < noteTypes.length - 1) {
                        // 合体！次の音符を作る
                        const nextType = noteTypes[a.noteType].next;
                        const newNote = createNote(nextType, (a.position.x + b.position.x) / 2, (a.position.y + b.position.y) / 2);
                        World.add(world, newNote);
                        // もとの音符を消す
                        World.remove(world, [a, b]);
                    }
                });
            });

            Render.run(render);
            Runner.run(Runner.create(), engine);
        </script>
        <p>スペースキーで音符を落とす</p>
    </body>

</html>
